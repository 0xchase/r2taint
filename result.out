00001445: program
.address 0x4006F0
000013ee: sub .plt()
.address 0x4006F0
00001239: 
.address 0x4006F0
00001240: #169 := mem[0x602008, el]:u64
.address 0x4006F0
00001243: RSP := RSP - 8
.address 0x4006F0
00001246: mem := mem with [RSP, el]:u64 <- #169
.address 0x4006F6
0000124e: call mem[0x602010, el]:u64 with noreturn


.address 0x400890
000013ef: sub __do_global_dtors_aux()
.address 0x400890
00000240: 
.address 0x400890
0000024b: #25 := mem[0x6020A8]
.address 0x400890
0000024e: CF := mem[0x6020A8] < 0
.address 0x400890
00000251: OF := high:1[mem[0x6020A8] & (mem[0x6020A8] ^ #25)]
.address 0x400890
00000254: AF := 0x10 = (0x10 & (#25 ^ mem[0x6020A8]))
.address 0x400890
00000257: PF := ~low:1[let $1 = #25 >> 4 ^ #25 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400890
0000025a: SF := high:1[#25]
.address 0x400890
0000025d: ZF := 0 = #25
.address 0x400897
00000267: when ~ZF goto %00000261
00001427: goto %000010cb

.address 0x400899
000010cb: 
.address 0x400899
000010d2: #155 := RBP
.address 0x400899
000010d5: RSP := RSP - 8
.address 0x400899
000010d8: mem := mem with [RSP, el]:u64 <- #155
.address 0x40089A
000010df: RBP := RSP
.address 0x40089D
000010e8: RSP := RSP - 8
.address 0x40089D
000010eb: mem := mem with [RSP, el]:u64 <- 0x4008A2
.address 0x40089D
000010ee: call @deregister_tm_clones with return %000010f0

.address 0x4008A2
000010f0: 
.address 0x4008A2
000010f6: RBP := mem[RSP, el]:u64
.address 0x4008A2
000010f9: RSP := RSP + 8
.address 0x4008A3
00001100: mem := mem with [0x6020A8] <- 1
00001428: goto %00000261

.address 0x4008AA
00000261: 
.address 0x4008AA
00000273: #27 := mem[RSP, el]:u64
.address 0x4008AA
00000276: RSP := RSP + 8
.address 0x4008AA
0000027a: call #27 with noreturn


.address 0x4007D0
000013f2: sub __gmon_start__()
.address 0x4007D0
00000005: 
.address 0x4007D0
0000000b: call mem[0x601FF8, el]:u64 with noreturn


.address 0x400C60
000013f3: sub __libc_csu_fini()
.address 0x400C60
00000e46: 
.address 0x400C60
00000e4d: #141 := mem[RSP, el]:u64
.address 0x400C60
00000e50: RSP := RSP + 8
.address 0x400C60
00000e54: call #141 with noreturn


.address 0x400BF0
000013f4: sub __libc_csu_init()
.address 0x400BF0
00000ca5: 
.address 0x400BF0
00000cac: #121 := R15
.address 0x400BF0
00000caf: RSP := RSP - 8
.address 0x400BF0
00000cb2: mem := mem with [RSP, el]:u64 <- #121
.address 0x400BF2
00000cbb: #122 := R14
.address 0x400BF2
00000cbe: RSP := RSP - 8
.address 0x400BF2
00000cc1: mem := mem with [RSP, el]:u64 <- #122
.address 0x400BF4
00000cc8: R15 := pad:64[low:32[RDI]]
.address 0x400BF7
00000cd1: #123 := R13
.address 0x400BF7
00000cd4: RSP := RSP - 8
.address 0x400BF7
00000cd7: mem := mem with [RSP, el]:u64 <- #123
.address 0x400BF9
00000ce0: #124 := R12
.address 0x400BF9
00000ce3: RSP := RSP - 8
.address 0x400BF9
00000ce6: mem := mem with [RSP, el]:u64 <- #124
.address 0x400BFB
00000ced: R12 := 0x601E10
.address 0x400C02
00000cf6: #125 := RBP
.address 0x400C02
00000cf9: RSP := RSP - 8
.address 0x400C02
00000cfc: mem := mem with [RSP, el]:u64 <- #125
.address 0x400C03
00000d03: RBP := 0x601E18
.address 0x400C0A
00000d0c: #126 := RBX
.address 0x400C0A
00000d0f: RSP := RSP - 8
.address 0x400C0A
00000d12: mem := mem with [RSP, el]:u64 <- #126
.address 0x400C0B
00000d19: R14 := RSI
.address 0x400C0E
00000d20: R13 := RDX
.address 0x400C11
00000d2f: #127 := RBP
.address 0x400C11
00000d32: #128 := R12
.address 0x400C11
00000d35: RBP := RBP - R12
.address 0x400C11
00000d38: CF := #127 < #128
.address 0x400C11
00000d3b: OF := high:1[(#127 ^ #128) & (#127 ^ RBP)]
.address 0x400C11
00000d3e: AF := 0x10 = (0x10 & (RBP ^ #127 ^ #128))
.address 0x400C11
00000d41: PF := ~low:1[let $1 = RBP >> 4 ^ RBP in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400C11
00000d44: SF := high:1[RBP]
.address 0x400C11
00000d47: ZF := 0 = RBP
.address 0x400C14
00000d55: #130 := RSP
.address 0x400C14
00000d58: RSP := RSP - 8
.address 0x400C14
00000d5b: CF := #130 < 8
.address 0x400C14
00000d5e: OF := high:1[(#130 ^ 8) & (#130 ^ RSP)]
.address 0x400C14
00000d61: AF := 0x10 = (0x10 & (RSP ^ #130 ^ 8))
.address 0x400C14
00000d64: PF := ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400C14
00000d67: SF := high:1[RSP]
.address 0x400C14
00000d6a: ZF := 0 = RSP
.address 0x400C18
00000d78: #133 := RBP
.address 0x400C18
00000d7b: RBP := RBP ~>> 3
.address 0x400C18
00000d7e: CF := high:1[#133 << 0x3D]
.address 0x400C18
00000d81: SF := high:1[RBP]
.address 0x400C18
00000d84: ZF := 0 = RBP
.address 0x400C18
00000d87: PF := ~low:1[let $1 = RBP >> 4 ^ RBP in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400C18
00000d8a: AF := unknown[bits]:u1
.address 0x400C18
00000d8d: OF := unknown[bits]:u1
.address 0x400C1C
00000d97: RSP := RSP - 8
.address 0x400C1C
00000d9a: mem := mem with [RSP, el]:u64 <- 0x400C21
.address 0x400C1C
00000d9d: call @_init with return %00000d9f

.address 0x400C21
00000d9f: 
.address 0x400C21
00000daa: #135 := RBP
.address 0x400C21
00000dad: OF := 0
.address 0x400C21
00000db0: CF := 0
.address 0x400C21
00000db3: AF := unknown[bits]:u1
.address 0x400C21
00000db6: PF := ~low:1[let $1 = #135 >> 4 ^ #135 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400C21
00000db9: SF := high:1[#135]
.address 0x400C21
00000dbc: ZF := 0 = #135
.address 0x400C24
00000dc6: when ZF goto %00000dc0
00001429: goto %00000e56

.address 0x400C26
00000e56: 
.address 0x400C26
00000e61: RBX := 0
.address 0x400C26
00000e64: AF := unknown[bits]:u1
.address 0x400C26
00000e67: ZF := 1
.address 0x400C26
00000e6a: PF := 1
.address 0x400C26
00000e6d: OF := 0
.address 0x400C26
00000e70: CF := 0
.address 0x400C26
00000e73: SF := 0
0000142a: goto %00000e78

.address 0x400C30
00000e78: 
.address 0x400C30
00000e7d: RDX := R13
.address 0x400C33
00000e84: RSI := R14
.address 0x400C36
00000e8b: RDI := pad:64[low:32[R15]]
.address 0x400C39
00000e95: #142 := mem[R12 + (RBX << 3), el]:u64
.address 0x400C39
00000e98: RSP := RSP - 8
.address 0x400C39
00000e9b: mem := mem with [RSP, el]:u64 <- 0x400C3D
.address 0x400C39
00000e9f: call #142 with return %00000ea1

.address 0x400C3D
00000ea1: 
.address 0x400C3D
00000ead: #143 := RBX
.address 0x400C3D
00000eb0: RBX := RBX + 1
.address 0x400C3D
00000eb3: CF := RBX < #143
.address 0x400C3D
00000eb6: OF := ~high:1[#143] & (high:1[#143] | high:1[RBX]) & ~(high:1[#143] & high:1[RBX])
.address 0x400C3D
00000eb9: AF := 0x10 = (0x10 & (RBX ^ #143 ^ 1))
.address 0x400C3D
00000ebc: PF := ~low:1[let $1 = RBX >> 4 ^ RBX in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400C3D
00000ebf: SF := high:1[RBX]
.address 0x400C3D
00000ec2: ZF := 0 = RBX
.address 0x400C41
00000ecf: #146 := RBX - RBP
.address 0x400C41
00000ed2: CF := RBX < RBP
.address 0x400C41
00000ed5: OF := high:1[(RBX ^ RBP) & (RBX ^ #146)]
.address 0x400C41
00000ed8: AF := 0x10 = (0x10 & (#146 ^ RBX ^ RBP))
.address 0x400C41
00000edb: PF := ~low:1[let $1 = #146 >> 4 ^ #146 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400C41
00000ede: SF := high:1[#146]
.address 0x400C41
00000ee1: ZF := 0 = #146
.address 0x400C44
00000eea: when ~ZF goto %00000e78
0000142b: goto %00000dc0

.address 0x400C46
00000dc0: 
.address 0x400C46
00000dd7: #137 := RSP
.address 0x400C46
00000dda: RSP := RSP + 8
.address 0x400C46
00000ddd: CF := RSP < #137
.address 0x400C46
00000de0: OF := ~high:1[#137] & (high:1[#137] | high:1[RSP]) & ~(high:1[#137] & high:1[RSP])
.address 0x400C46
00000de3: AF := 0x10 = (0x10 & (RSP ^ #137 ^ 8))
.address 0x400C46
00000de6: PF := ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400C46
00000de9: SF := high:1[RSP]
.address 0x400C46
00000dec: ZF := 0 = RSP
.address 0x400C4A
00000df4: RBX := mem[RSP, el]:u64
.address 0x400C4A
00000df7: RSP := RSP + 8
.address 0x400C4B
00000dff: RBP := mem[RSP, el]:u64
.address 0x400C4B
00000e02: RSP := RSP + 8
.address 0x400C4C
00000e0a: R12 := mem[RSP, el]:u64
.address 0x400C4C
00000e0d: RSP := RSP + 8
.address 0x400C4E
00000e15: R13 := mem[RSP, el]:u64
.address 0x400C4E
00000e18: RSP := RSP + 8
.address 0x400C50
00000e20: R14 := mem[RSP, el]:u64
.address 0x400C50
00000e23: RSP := RSP + 8
.address 0x400C52
00000e2b: R15 := mem[RSP, el]:u64
.address 0x400C52
00000e2e: RSP := RSP + 8
.address 0x400C54
00000e37: #140 := mem[RSP, el]:u64
.address 0x400C54
00000e3a: RSP := RSP + 8
.address 0x400C54
00000e3e: call #140 with noreturn


.address 0x400770
000013f8: sub __libc_start_main(__libc_start_main_main, __libc_start_main_arg2, __libc_start_main_arg3, __libc_start_main_auxv, __libc_start_main_result)
00001446: __libc_start_main_main :: in u64 = RDI
00001447: __libc_start_main_arg2 :: in u32 = RSI
00001448: __libc_start_main_arg3 :: in out u64 = RDX
00001449: __libc_start_main_auxv :: in out u64 = RCX
0000144a: __libc_start_main_result :: out u32 = RAX
.address 0x400770
0000009f: 
.address 0x400770
00001307: call mem[0x602050, el]:u64 with noreturn


.address 0x400730
000013f9: sub __stack_chk_fail()
.address 0x400730
00000ef4: 
.address 0x400730
000012a3: call mem[0x602030, el]:u64 with noreturn


.address 0x400C64
000013fa: sub _fini()
.address 0x400C64
00001398: 
.address 0x400C64
000013a4: #183 := RSP
.address 0x400C64
000013a7: RSP := RSP - 8
.address 0x400C64
000013aa: CF := #183 < 8
.address 0x400C64
000013ad: OF := high:1[(#183 ^ 8) & (#183 ^ RSP)]
.address 0x400C64
000013b0: AF := 0x10 = (0x10 & (RSP ^ #183 ^ 8))
.address 0x400C64
000013b3: PF := ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400C64
000013b6: SF := high:1[RSP]
.address 0x400C64
000013b9: ZF := 0 = RSP
.address 0x400C68
000013c7: #186 := RSP
.address 0x400C68
000013ca: RSP := RSP + 8
.address 0x400C68
000013cd: CF := RSP < #186
.address 0x400C68
000013d0: OF := ~high:1[#186] & (high:1[#186] | high:1[RSP]) & ~(high:1[#186] & high:1[RSP])
.address 0x400C68
000013d3: AF := 0x10 = (0x10 & (RSP ^ #186 ^ 8))
.address 0x400C68
000013d6: PF := ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400C68
000013d9: SF := high:1[RSP]
.address 0x400C68
000013dc: ZF := 0 = RSP
.address 0x400C6C
000013e5: #189 := mem[RSP, el]:u64
.address 0x400C6C
000013e8: RSP := RSP + 8
.address 0x400C6C
000013ec: call #189 with noreturn


.address 0x4006D0
000013fb: sub _init()
.address 0x4006D0
00000d93: 
.address 0x4006D0
000011ad: #160 := RSP
.address 0x4006D0
000011b0: RSP := RSP - 8
.address 0x4006D0
000011b3: CF := #160 < 8
.address 0x4006D0
000011b6: OF := high:1[(#160 ^ 8) & (#160 ^ RSP)]
.address 0x4006D0
000011b9: AF := 0x10 = (0x10 & (RSP ^ #160 ^ 8))
.address 0x4006D0
000011bc: PF := ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x4006D0
000011bf: SF := high:1[RSP]
.address 0x4006D0
000011c2: ZF := 0 = RSP
.address 0x4006D4
000011c9: RAX := mem[0x601FF8, el]:u64
.address 0x4006DB
000011d6: #163 := RAX
.address 0x4006DB
000011d9: OF := 0
.address 0x4006DB
000011dc: CF := 0
.address 0x4006DB
000011df: AF := unknown[bits]:u1
.address 0x4006DB
000011e2: PF := ~low:1[let $1 = #163 >> 4 ^ #163 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x4006DB
000011e5: SF := high:1[#163]
.address 0x4006DB
000011e8: ZF := 0 = #163
.address 0x4006DE
000011f2: when ZF goto %000011ec
0000142c: goto %0000122a

.address 0x4006E0
0000122a: 
.address 0x4006E0
00001231: RSP := RSP - 8
.address 0x4006E0
00001234: mem := mem with [RSP, el]:u64 <- 0x4006E5
.address 0x4006E0
00001237: call @__gmon_start__ with return %000011ec

.address 0x4006E5
000011ec: 
.address 0x4006E5
00001203: #165 := RSP
.address 0x4006E5
00001206: RSP := RSP + 8
.address 0x4006E5
00001209: CF := RSP < #165
.address 0x4006E5
0000120c: OF := ~high:1[#165] & (high:1[#165] | high:1[RSP]) & ~(high:1[#165] & high:1[RSP])
.address 0x4006E5
0000120f: AF := 0x10 = (0x10 & (RSP ^ #165 ^ 8))
.address 0x4006E5
00001212: PF := ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x4006E5
00001215: SF := high:1[RSP]
.address 0x4006E5
00001218: ZF := 0 = RSP
.address 0x4006E9
00001221: #168 := mem[RSP, el]:u64
.address 0x4006E9
00001224: RSP := RSP + 8
.address 0x4006E9
00001228: call #168 with noreturn


.address 0x4007E0
000013fd: sub _start()
.address 0x4007E0
00000011: 
.address 0x4007E0
0000001c: RBP := 0
.address 0x4007E0
0000001f: AF := unknown[bits]:u1
.address 0x4007E0
00000022: ZF := 1
.address 0x4007E0
00000025: PF := 1
.address 0x4007E0
00000028: OF := 0
.address 0x4007E0
0000002b: CF := 0
.address 0x4007E0
0000002e: SF := 0
.address 0x4007E2
00000035: R9 := RDX
.address 0x4007E5
0000003d: RSI := mem[RSP, el]:u64
.address 0x4007E5
00000040: RSP := RSP + 8
.address 0x4007E6
00000047: RDX := RSP
.address 0x4007E9
00000054: RSP := RSP & 0xFFFFFFFFFFFFFFF0
.address 0x4007E9
00000057: OF := 0
.address 0x4007E9
0000005a: CF := 0
.address 0x4007E9
0000005d: AF := unknown[bits]:u1
.address 0x4007E9
00000060: PF := ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x4007E9
00000063: SF := high:1[RSP]
.address 0x4007E9
00000066: ZF := 0 = RSP
.address 0x4007ED
0000006f: #2 := RAX
.address 0x4007ED
00000072: RSP := RSP - 8
.address 0x4007ED
00000075: mem := mem with [RSP, el]:u64 <- #2
.address 0x4007EE
0000007e: #3 := RSP
.address 0x4007EE
00000081: RSP := RSP - 8
.address 0x4007EE
00000084: mem := mem with [RSP, el]:u64 <- #3
.address 0x4007EF
0000008b: R8 := 0x400C60
.address 0x4007F6
00000092: RCX := 0x400BF0
.address 0x4007FD
00000099: RDI := 0x4008D6
.address 0x400804
000000a3: RSP := RSP - 8
.address 0x400804
000000a6: mem := mem with [RSP, el]:u64 <- 0x400809
.address 0x400804
00001469: __libc_start_main_main := RDI
.address 0x400804
0000146a: __libc_start_main_arg2 := RSI
.address 0x400804
0000146b: __libc_start_main_arg3 := RDX
.address 0x400804
0000146c: __libc_start_main_auxv := RCX
.address 0x400804
000000a9: call @__libc_start_main with return %000000ab

.address 0x400809
000000ab: 
.address 0x400804
0000146f: __libc_start_main_auxv := RCX
.address 0x400804
0000146e: __libc_start_main_arg3 := RDX
.address 0x400804
0000146d: __libc_start_main_result := RAX
0000142d: call @deregister_tm_clones with noreturn


.address 0x400810
000013ff: sub deregister_tm_clones()
.address 0x400810
000000b1: 
.address 0x400810
000000b6: RAX := 0x602097
.address 0x400815
000000bf: #4 := RBP
.address 0x400815
000000c2: RSP := RSP - 8
.address 0x400815
000000c5: mem := mem with [RSP, el]:u64 <- #4
.address 0x400816
000000d3: #5 := RAX
.address 0x400816
000000d6: RAX := RAX - 0x602090
.address 0x400816
000000d9: CF := #5 < 0x602090
.address 0x400816
000000dc: OF := high:1[(#5 ^ 0x602090) & (#5 ^ RAX)]
.address 0x400816
000000df: AF := 0x10 = (0x10 & (RAX ^ #5 ^ 0x602090))
.address 0x400816
000000e2: PF := ~low:1[let $1 = RAX >> 4 ^ RAX in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400816
000000e5: SF := high:1[RAX]
.address 0x400816
000000e8: ZF := 0 = RAX
.address 0x40081C
000000f5: #8 := RAX - 0xE
.address 0x40081C
000000f8: CF := RAX < 0xE
.address 0x40081C
000000fb: OF := high:1[(RAX ^ 0xE) & (RAX ^ #8)]
.address 0x40081C
000000fe: AF := 0x10 = (0x10 & (#8 ^ RAX ^ 0xE))
.address 0x40081C
00000101: PF := ~low:1[let $1 = #8 >> 4 ^ #8 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x40081C
00000104: SF := high:1[#8]
.address 0x40081C
00000107: ZF := 0 = #8
.address 0x400820
0000010e: RBP := RSP
.address 0x400823
00000118: when CF | ZF goto %00000112
0000142e: goto %00001152

.address 0x400825
00001152: 
.address 0x400825
00001157: RAX := 0
.address 0x40082A
00001164: #158 := RAX
.address 0x40082A
00001167: OF := 0
.address 0x40082A
0000116a: CF := 0
.address 0x40082A
0000116d: AF := unknown[bits]:u1
.address 0x40082A
00001170: PF := ~low:1[let $1 = #158 >> 4 ^ #158 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x40082A
00001173: SF := high:1[#158]
.address 0x40082A
00001176: ZF := 0 = #158
.address 0x40082D
0000117f: when ZF goto %00000112
0000142f: goto %00001185

.address 0x400840
00000112: 
.address 0x400840
00000123: RBP := mem[RSP, el]:u64
.address 0x400840
00000126: RSP := RSP + 8
.address 0x400841
0000012f: #10 := mem[RSP, el]:u64
.address 0x400841
00000132: RSP := RSP + 8
.address 0x400841
00000136: call #10 with noreturn

.address 0x40082F
00001185: 
.address 0x40082F
0000118b: RBP := mem[RSP, el]:u64
.address 0x40082F
0000118e: RSP := RSP + 8
.address 0x400830
00001195: RDI := 0x602090
.address 0x400835
0000119d: call RAX with noreturn


.address 0x4007B0
00001402: sub fflush()
.address 0x4007B0
000003c1: 
.address 0x4007B0
0000136b: call mem[0x602070, el]:u64 with noreturn


.address 0x400780
00001403: sub fgets(fgets_s, fgets_size, fgets_stream, fgets_result)
0000144b: fgets_s :: in out u64 = RDI
0000144c: fgets_size :: in u32 = RSI
0000144d: fgets_stream :: in out u64 = RDX
0000144e: fgets_result :: out u64 = RAX
.address 0x400780
000003ed: 
.address 0x400780
00001320: call mem[0x602058, el]:u64 with noreturn


.address 0x4008B0
00001404: sub frame_dummy()
.address 0x4008B0
0000027f: 
.address 0x4008B0
00000284: RDI := 0x601E20
.address 0x4008B5
00000291: #28 := mem[RDI, el]:u64
.address 0x4008B5
00000294: CF := mem[RDI, el]:u64 < 0
.address 0x4008B5
00000297: OF := high:1[mem[RDI, el]:u64 & (mem[RDI, el]:u64 ^ #28)]
.address 0x4008B5
0000029a: AF := 0x10 = (0x10 & (#28 ^ mem[RDI, el]:u64))
.address 0x4008B5
0000029d: PF := ~low:1[let $1 = #28 >> 4 ^ #28 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x4008B5
000002a0: SF := high:1[#28]
.address 0x4008B5
000002a3: ZF := 0 = #28
.address 0x4008B9
000002ad: when ~ZF goto %000002a7
00001430: goto %000002da

.address 0x4008C0
000002a7: 
.address 0x4008C0
000002b7: RAX := 0
.address 0x4008C5
000002c4: #30 := RAX
.address 0x4008C5
000002c7: OF := 0
.address 0x4008C5
000002ca: CF := 0
.address 0x4008C5
000002cd: AF := unknown[bits]:u1
.address 0x4008C5
000002d0: PF := ~low:1[let $1 = #30 >> 4 ^ #30 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x4008C5
000002d3: SF := high:1[#30]
.address 0x4008C5
000002d6: ZF := 0 = #30
.address 0x4008C8
000002e0: when ZF goto %000002da
00001431: goto %000002ef

.address 0x4008CA
000002ef: 
.address 0x4008CA
000002f6: #32 := RBP
.address 0x4008CA
000002f9: RSP := RSP - 8
.address 0x4008CA
000002fc: mem := mem with [RSP, el]:u64 <- #32
.address 0x4008CB
00000303: RBP := RSP
.address 0x4008CE
0000030d: #33 := RAX
.address 0x4008CE
00000310: RSP := RSP - 8
.address 0x4008CE
00000313: mem := mem with [RSP, el]:u64 <- 0x4008D0
.address 0x4008CE
00000317: call #33 with return %00000319

.address 0x4008D0
00000319: 
.address 0x4008D0
0000031f: RBP := mem[RSP, el]:u64
.address 0x4008D0
00000322: RSP := RSP + 8
.address 0x4008D1
00000329: call @register_tm_clones with noreturn

.address 0x4008BB
000002da: 
.address 0x4008BB
000002ea: call @register_tm_clones with noreturn


.address 0x400700
00001407: sub free(free_ptr)
0000144f: free_ptr :: in out u64 = RDI
.address 0x400700
00000fb1: 
.address 0x400700
00001258: call mem[0x602018, el]:u64 with noreturn


.address 0x400A70
00001408: sub hash()
.address 0x400A70
00000650: 
.address 0x400A70
00000662: #60 := RBP
.address 0x400A70
.tainted-regs {RSP => [%00000576]}
00000665: RSP := RSP - 8
.address 0x400A70
.tainted-regs {RSP => [%00000576]}
00000668: mem := mem with [RSP, el]:u64 <- #60
.address 0x400A71
.tainted-regs {RSP => [%00000576]}
0000066f: RBP := RSP
.address 0x400A74
.tainted-regs {RSP => [%00000576]}
0000067d: #61 := RSP
.address 0x400A74
.tainted-regs {RSP => [%00000576]}
00000680: RSP := RSP - 0x50
.address 0x400A74
.tainted-regs {#61 => [%00000576]}
00000683: CF := #61 < 0x50
.address 0x400A74
.tainted-regs {RSP => [%00000576], #61 => [%00000576]}
00000686: OF := high:1[(#61 ^ 0x50) & (#61 ^ RSP)]
.address 0x400A74
.tainted-regs {RSP => [%00000576], #61 => [%00000576]}
00000689: AF := 0x10 = (0x10 & (RSP ^ #61 ^ 0x50))
.address 0x400A74
.tainted-regs {RSP => [%00000576], $1 => [%00000576], $2 => [%00000576]}
0000068c: PF := ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400A74
.tainted-regs {RSP => [%00000576]}
0000068f: SF := high:1[RSP]
.address 0x400A74
.tainted-regs {RSP => [%00000576]}
00000692: ZF := 0 = RSP
.address 0x400A78
.tainted-regs {RBP => [%00000576]}
00000699: mem := mem with [RBP - 0x44, el]:u32 <- low:32[RDI]
.address 0x400A7B
.tainted-regs {RBP => [%00000576], RSI => [%00000579]}
000006a0: mem := mem with [RBP - 0x50, el]:u64 <- RSI
.address 0x400A7F
000006a7: RAX := mem[FS_BASE + 0x28, el]:u64
.address 0x400A88
.tainted-regs {RBP => [%00000576]}
000006ae: mem := mem with [RBP - 8, el]:u64 <- RAX
.address 0x400A8C
000006bb: RAX := 0
.address 0x400A8C
000006be: AF := unknown[bits]:u1
.address 0x400A8C
000006c1: ZF := 1
.address 0x400A8C
000006c4: PF := 1
.address 0x400A8C
000006c7: OF := 0
.address 0x400A8C
000006ca: CF := 0
.address 0x400A8C
000006cd: SF := 0
.address 0x400A8E
.tainted-regs {RBP => [%00000576]}
000006d4: mem := mem with [RBP - 0x28, el]:u64 <- 0x400D46
.address 0x400A96
.tainted-regs {RBP => [%00000576]}
000006db: mem := mem with [RBP - 0x20, el]:u64 <- 0
.address 0x400A9E
.tainted-regs {RBP => [%00000576]}
000006e2: mem := mem with [RBP - 0x18] <- 0
.address 0x400AA2
.tainted-regs {RBP => [%00000576]}
000006e9: mem := mem with [RBP - 0x34, el]:u32 <- 0
.address 0x400AA9
000006f1: goto %000006ed

.address 0x400AEE
000006ed: 
.address 0x400AEE
.tainted-regs {RBP => [%00000576]}
000006fd: #64 := mem[RBP - 0x44, el]:u32
.address 0x400AEE
.tainted-regs {RBP => [%00000576]}
00000700: CF := mem[RBP - 0x44, el]:u32 < 0
.address 0x400AEE
.tainted-regs {RBP => [%00000576]}
00000703: OF := high:1[mem[RBP - 0x44, el]:u32 & (mem[RBP - 0x44, el]:u32 ^ #64)]
.address 0x400AEE
.tainted-regs {RBP => [%00000576]}
00000706: AF := 0x10 = (0x10 & (#64 ^ mem[RBP - 0x44, el]:u32))
.address 0x400AEE
00000709: PF := ~low:1[let $1 = #64 >> 4 ^ #64 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400AEE
0000070c: SF := high:1[#64]
.address 0x400AEE
0000070f: ZF := 0 = #64
.address 0x400AF2
00000719: when ~ZF goto %00000713
00001432: goto %000008f6

.address 0x400AF4
000008f6: 
.address 0x400AF4
.tainted-regs {RBP => [%00000576]}
000008fb: mem := mem with [RBP - 0x3C, el]:u32 <- 0
.address 0x400AFB
00000903: goto %000008ff

.address 0x400B34
000008ff: 
.address 0x400B34
.tainted-regs {RBP => [%00000576]}
00000909: RAX := pad:64[mem[RBP - 0x3C, el]:u32]
.address 0x400B37
.tainted-regs {RBP => [%00000576]}
00000916: #90 := low:32[RAX] - mem[RBP - 0x34, el]:u32
.address 0x400B37
.tainted-regs {RBP => [%00000576]}
00000919: CF := low:32[RAX] < mem[RBP - 0x34, el]:u32
.address 0x400B37
.tainted-regs {RBP => [%00000576]}
0000091c: OF := high:1[(low:32[RAX] ^ mem[RBP - 0x34, el]:u32) & (low:32[RAX] ^ #90)]
.address 0x400B37
.tainted-regs {RBP => [%00000576]}
0000091f: AF := 0x10 = (0x10 & (#90 ^ low:32[RAX] ^ mem[RBP - 0x34, el]:u32))
.address 0x400B37
00000922: PF := ~low:1[let $1 = #90 >> 4 ^ #90 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400B37
00000925: SF := high:1[#90]
.address 0x400B37
00000928: ZF := 0 = #90
.address 0x400B3A
00000932: when CF goto %0000092c
00001433: goto %000009fb

.address 0x400B3C
000009fb: 
.address 0x400B3C
.tainted-regs {RBP => [%00000576]}
00000a00: mem := mem with [RBP - 0x34, el]:u32 <- 0
.address 0x400B43
.tainted-regs {RBP => [%00000576]}
00000a07: mem := mem with [RBP - 0x38, el]:u32 <- 0xFFFFFFFF
.address 0x400B4A
00000a0f: goto %00000a0b

.address 0x400B96
00000a0b: 
.address 0x400B96
.tainted-regs {RBP => [%00000576]}
00000a15: RAX := pad:64[mem[RBP - 0x34, el]:u32]
.address 0x400B99
.tainted-regs {RBP => [%00000576]}
00000a1c: RAX := pad:64[pad:32[mem[RBP + RAX - 0x20]]]
.address 0x400B9E
00000a29: #101 := low:8[RAX]
.address 0x400B9E
00000a2c: OF := 0
.address 0x400B9E
00000a2f: CF := 0
.address 0x400B9E
00000a32: AF := unknown[bits]:u1
.address 0x400B9E
00000a35: PF := ~low:1[let $1 = #101 >> 4 ^ #101 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400B9E
00000a38: SF := high:1[#101]
.address 0x400B9E
00000a3b: ZF := 0 = #101
.address 0x400BA0
00000a45: when ~ZF goto %00000a3f
00001434: goto %00000bd9

.address 0x400BA2
00000bd9: 
.address 0x400BA2
.tainted-regs {RBP => [%00000576]}
00000bde: RAX := pad:64[mem[RBP - 0x38, el]:u32]
.address 0x400BA5
00000be5: RAX := pad:64[~low:32[RAX]]
.address 0x400BA7
00000bec: RDX := pad:64[low:32[RAX]]
.address 0x400BA9
.tainted-regs {RBP => [%00000576]}
00000bf3: RAX := low:64[RBP - 0x20]
.address 0x400BAD
00000bfa: RSI := 0x400D4A
.address 0x400BB2
.tainted-regs {RAX => [%00000576]}
00000c01: RDI := RAX
.address 0x400BB5
00000c08: RAX := 0
.address 0x400BBA
.tainted-regs {RSP => [%00000576]}
00000c12: RSP := RSP - 8
.address 0x400BBA
.tainted-regs {RSP => [%00000576]}
00000c15: mem := mem with [RSP, el]:u64 <- 0x400BBF
.address 0x400BBA
00001470: sprintf_format := RSI
.address 0x400BBA
.tainted-regs {RDI => [%00000576]}
00001471: sprintf_str := RDI
.address 0x400BBA
00000c18: call @sprintf with return %00000c1a

.address 0x400BBF
00000c1a: 
.address 0x400BBA
.tainted-regs {RDI => [%00000576]}
00001476: sprintf_str := RDI
.address 0x400BBA
00001475: sprintf_result := RAX
.address 0x400BBF
.tainted-regs {RBP => [%00000576]}
00000c1f: RCX := low:64[RBP - 0x20]
.address 0x400BC3
.tainted-regs {RBP => [%00000576]}
00000c26: RAX := mem[RBP - 0x50, el]:u64
.address 0x400BC7
00000c2d: RDX := 8
.address 0x400BCC
.tainted-regs {RCX => [%00000576]}
00000c34: RSI := RCX
.address 0x400BCF
.tainted-regs {RAX => [%00000579]}
00000c3b: RDI := RAX
.address 0x400BD2
.tainted-regs {RSP => [%00000576]}
00000c45: RSP := RSP - 8
.address 0x400BD2
.tainted-regs {RSP => [%00000576]}
00000c48: mem := mem with [RSP, el]:u64 <- 0x400BD7
.address 0x400BD2
.tainted-regs {RSI => [%00000576]}
00001472: strncat_src := RSI
.address 0x400BD2
00001473: strncat_n := RDX
.address 0x400BD2
.tainted-regs {RDI => [%00000579]}
00001474: strncat_dst := RDI
.address 0x400BD2
00000c4b: call @strncat with return %00000c4d

.address 0x400BD7
00000c4d: 
.address 0x400BD2
.tainted-regs {RDI => [%00000579]}
00001478: strncat_dst := RDI
.address 0x400BD2
.tainted-regs {RAX => [%00000579]}
00001477: strncat_result := RAX
.address 0x400BD8
.tainted-regs {RBP => [%00000576]}
00000c55: RAX := mem[RBP - 8, el]:u64
.address 0x400BDC
00000c62: RAX := RAX ^ mem[FS_BASE + 0x28, el]:u64
.address 0x400BDC
00000c65: OF := 0
.address 0x400BDC
00000c68: CF := 0
.address 0x400BDC
00000c6b: AF := unknown[bits]:u1
.address 0x400BDC
00000c6e: PF := ~low:1[let $1 = RAX >> 4 ^ RAX in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400BDC
00000c71: SF := high:1[RAX]
.address 0x400BDC
00000c74: ZF := 0 = RAX
.address 0x400BE5
00000c7e: when ZF goto %00000c78
00001435: goto %00000ef0

.address 0x400BE7
00000ef0: 
.address 0x400BE7
.tainted-regs {RSP => [%00000576]}
00000ef8: RSP := RSP - 8
.address 0x400BE7
.tainted-regs {RSP => [%00000576]}
00000efb: mem := mem with [RSP, el]:u64 <- 0x400BEC
.address 0x400BE7
00000efe: call @__stack_chk_fail with return %00000c78

.address 0x400BEC
00000c78: 
.address 0x400BEC
.tainted-regs {RBP => [%00000576]}
00000c8a: RSP := RBP
.address 0x400BEC
.tainted-regs {RSP => [%00000576]}
00000c8d: RBP := mem[RSP, el]:u64
.address 0x400BEC
.tainted-regs {RSP => [%00000576]}
00000c90: RSP := RSP + 8
.address 0x400BED
.tainted-regs {RSP => [%00000576]}
00000c99: #120 := mem[RSP, el]:u64
.address 0x400BED
.tainted-regs {RSP => [%00000576]}
00000c9c: RSP := RSP + 8
.address 0x400BED
00000ca0: call #120 with noreturn

.address 0x400B4C
00000a3f: 
.address 0x400B4C
.tainted-regs {RBP => [%00000576]}
00000a4f: RAX := pad:64[mem[RBP - 0x34, el]:u32]
.address 0x400B4F
.tainted-regs {RBP => [%00000576]}
00000a56: RAX := pad:64[pad:32[mem[RBP + RAX - 0x20]]]
.address 0x400B54
00000a5d: RAX := pad:64[extend:32[low:8[RAX]]]
.address 0x400B57
.tainted-regs {RBP => [%00000576]}
00000a64: mem := mem with [RBP - 0x30, el]:u32 <- low:32[RAX]
.address 0x400B5A
.tainted-regs {RBP => [%00000576]}
00000a6b: RAX := pad:64[mem[RBP - 0x30, el]:u32]
.address 0x400B5D
.tainted-regs {RBP => [%00000576]}
00000a78: mem := mem
                     with [RBP - 0x38, el]:u32 <- mem[RBP - 0x38, el]:u32 ^ low:32[RAX]
.address 0x400B5D
00000a7b: OF := 0
.address 0x400B5D
00000a7e: CF := 0
.address 0x400B5D
00000a81: AF := unknown[bits]:u1
.address 0x400B5D
.tainted-regs {RBP => [%00000576]}
00000a84: PF := ~low:1[let $1 = mem[RBP - 0x38, el]:u32 >> 4 ^ mem[RBP - 0x38, el]:u32 in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400B5D
.tainted-regs {RBP => [%00000576]}
00000a87: SF := high:1[mem[RBP - 0x38, el]:u32]
.address 0x400B5D
.tainted-regs {RBP => [%00000576]}
00000a8a: ZF := 0 = mem[RBP - 0x38, el]:u32
.address 0x400B60
.tainted-regs {RBP => [%00000576]}
00000a91: mem := mem with [RBP - 0x3C, el]:u32 <- 8
.address 0x400B67
00000a99: goto %00000a95

.address 0x400B8C
00000a95: 
.address 0x400B8C
.tainted-regs {RBP => [%00000576]}
00000aa5: #104 := mem[RBP - 0x3C, el]:u32
.address 0x400B8C
.tainted-regs {RBP => [%00000576]}
00000aa8: CF := mem[RBP - 0x3C, el]:u32 < 0
.address 0x400B8C
.tainted-regs {RBP => [%00000576]}
00000aab: OF := high:1[mem[RBP - 0x3C, el]:u32 & (mem[RBP - 0x3C, el]:u32 ^ #104)]
.address 0x400B8C
.tainted-regs {RBP => [%00000576]}
00000aae: AF := 0x10 = (0x10 & (#104 ^ mem[RBP - 0x3C, el]:u32))
.address 0x400B8C
00000ab1: PF := ~low:1[let $1 = #104 >> 4 ^ #104 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400B8C
00000ab4: SF := high:1[#104]
.address 0x400B8C
00000ab7: ZF := 0 = #104
.address 0x400B90
00000ac1: when ~ZF goto %00000abb
00001436: goto %00000bb6

.address 0x400B92
00000bb6: 
.address 0x400B92
.tainted-regs {RBP => [%00000576]}
00000bc2: #116 := mem[RBP - 0x34, el]:u32
.address 0x400B92
.tainted-regs {RBP => [%00000576]}
00000bc5: mem := mem with [RBP - 0x34, el]:u32 <- mem[RBP - 0x34, el]:u32 + 1
.address 0x400B92
.tainted-regs {RBP => [%00000576]}
00000bc8: CF := mem[RBP - 0x34, el]:u32 < #116
.address 0x400B92
.tainted-regs {RBP => [%00000576]}
00000bcb: OF := ~high:1[#116] & (high:1[#116] | high:1[mem[RBP - 0x34, el]:u32]) & ~(
high:1[#116] & high:1[mem[RBP - 0x34, el]:u32])
.address 0x400B92
.tainted-regs {RBP => [%00000576]}
00000bce: AF := 0x10 = (0x10 & (mem[RBP - 0x34, el]:u32 ^ #116 ^ 1))
.address 0x400B92
.tainted-regs {RBP => [%00000576]}
00000bd1: PF := ~low:1[let $1 = mem[RBP - 0x34, el]:u32 >> 4 ^ mem[RBP - 0x34, el]:u32 in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400B92
.tainted-regs {RBP => [%00000576]}
00000bd4: SF := high:1[mem[RBP - 0x34, el]:u32]
.address 0x400B92
.tainted-regs {RBP => [%00000576]}
00000bd7: ZF := 0 = mem[RBP - 0x34, el]:u32
00001437: goto %00000a0b

.address 0x400B69
00000abb: 
.address 0x400B69
.tainted-regs {RBP => [%00000576]}
00000acb: RAX := pad:64[mem[RBP - 0x38, el]:u32]
.address 0x400B6C
00000ad8: RAX := pad:64[low:32[RAX] & 1]
.address 0x400B6C
00000adb: OF := 0
.address 0x400B6C
00000ade: CF := 0
.address 0x400B6C
00000ae1: AF := unknown[bits]:u1
.address 0x400B6C
00000ae4: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400B6C
00000ae7: SF := high:1[low:32[RAX]]
.address 0x400B6C
00000aea: ZF := 0 = low:32[RAX]
.address 0x400B6F
00000af8: #107 := low:32[RAX]
.address 0x400B6F
00000afb: RAX := pad:64[-low:32[RAX]]
.address 0x400B6F
00000afe: CF := if #107 = 0 then 0 else 1
.address 0x400B6F
00000b01: OF := if #107 = 0x80000000 then 1 else 0
.address 0x400B6F
00000b04: AF := 0x10 = (0x10 & (low:32[RAX] ^ #107))
.address 0x400B6F
00000b07: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400B6F
00000b0a: SF := high:1[low:32[RAX]]
.address 0x400B6F
00000b0d: ZF := 0 = low:32[RAX]
.address 0x400B71
.tainted-regs {RBP => [%00000576]}
00000b14: mem := mem with [RBP - 0x2C, el]:u32 <- low:32[RAX]
.address 0x400B74
.tainted-regs {RBP => [%00000576]}
00000b1b: RAX := pad:64[mem[RBP - 0x38, el]:u32]
.address 0x400B77
00000b29: #109 := low:32[RAX]
.address 0x400B77
00000b2c: RAX := pad:64[low:32[RAX] >> 1]
.address 0x400B77
00000b2f: CF := high:1[#109 << 0x1F]
.address 0x400B77
00000b32: SF := high:1[low:32[RAX]]
.address 0x400B77
00000b35: ZF := 0 = low:32[RAX]
.address 0x400B77
00000b38: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400B77
00000b3b: AF := unknown[bits]:u1
.address 0x400B77
00000b3e: OF := high:1[#109]
.address 0x400B79
00000b45: RDX := pad:64[low:32[RAX]]
.address 0x400B7B
.tainted-regs {RBP => [%00000576]}
00000b4c: RAX := pad:64[mem[RBP - 0x2C, el]:u32]
.address 0x400B7E
00000b59: RAX := pad:64[low:32[RAX] & 0xEDB88320]
.address 0x400B7E
00000b5c: OF := 0
.address 0x400B7E
00000b5f: CF := 0
.address 0x400B7E
00000b62: AF := unknown[bits]:u1
.address 0x400B7E
00000b65: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400B7E
00000b68: SF := high:1[low:32[RAX]]
.address 0x400B7E
00000b6b: ZF := 0 = low:32[RAX]
.address 0x400B83
00000b78: RAX := pad:64[low:32[RAX] ^ low:32[RDX]]
.address 0x400B83
00000b7b: OF := 0
.address 0x400B83
00000b7e: CF := 0
.address 0x400B83
00000b81: AF := unknown[bits]:u1
.address 0x400B83
00000b84: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400B83
00000b87: SF := high:1[low:32[RAX]]
.address 0x400B83
00000b8a: ZF := 0 = low:32[RAX]
.address 0x400B85
.tainted-regs {RBP => [%00000576]}
00000b91: mem := mem with [RBP - 0x38, el]:u32 <- low:32[RAX]
.address 0x400B88
.tainted-regs {RBP => [%00000576]}
00000b9f: #113 := mem[RBP - 0x3C, el]:u32
.address 0x400B88
.tainted-regs {RBP => [%00000576]}
00000ba2: mem := mem with [RBP - 0x3C, el]:u32 <- mem[RBP - 0x3C, el]:u32 - 1
.address 0x400B88
00000ba5: CF := #113 < 1
.address 0x400B88
.tainted-regs {RBP => [%00000576]}
00000ba8: OF := high:1[(#113 ^ 1) & (#113 ^ mem[RBP - 0x3C, el]:u32)]
.address 0x400B88
.tainted-regs {RBP => [%00000576]}
00000bab: AF := 0x10 = (0x10 & (mem[RBP - 0x3C, el]:u32 ^ #113 ^ 1))
.address 0x400B88
.tainted-regs {RBP => [%00000576]}
00000bae: PF := ~low:1[let $1 = mem[RBP - 0x3C, el]:u32 >> 4 ^ mem[RBP - 0x3C, el]:u32 in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400B88
.tainted-regs {RBP => [%00000576]}
00000bb1: SF := high:1[mem[RBP - 0x3C, el]:u32]
.address 0x400B88
.tainted-regs {RBP => [%00000576]}
00000bb4: ZF := 0 = mem[RBP - 0x3C, el]:u32
00001438: goto %00000a95

.address 0x400AFD
0000092c: 
.address 0x400AFD
.tainted-regs {RBP => [%00000576]}
0000093c: RAX := pad:64[mem[RBP - 0x3C, el]:u32]
.address 0x400B00
.tainted-regs {RBP => [%00000576]}
00000943: RAX := pad:64[pad:32[mem[RBP + RAX - 0x20]]]
.address 0x400B05
.tainted-regs {RBP => [%00000576]}
0000094a: mem := mem with [RBP - 0x3D] <- low:8[RAX]
.address 0x400B08
.tainted-regs {RBP => [%00000576]}
00000951: RAX := pad:64[mem[RBP - 0x34, el]:u32]
.address 0x400B0B
0000095f: #92 := low:32[RAX]
.address 0x400B0B
00000962: RAX := pad:64[low:32[RAX] - 1]
.address 0x400B0B
00000965: CF := #92 < 1
.address 0x400B0B
00000968: OF := high:1[(#92 ^ 1) & (#92 ^ low:32[RAX])]
.address 0x400B0B
0000096b: AF := 0x10 = (0x10 & (low:32[RAX] ^ #92 ^ 1))
.address 0x400B0B
0000096e: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400B0B
00000971: SF := high:1[low:32[RAX]]
.address 0x400B0B
00000974: ZF := 0 = low:32[RAX]
.address 0x400B0E
0000097b: RAX := pad:64[low:32[RAX]]
.address 0x400B10
.tainted-regs {RBP => [%00000576]}
00000982: RDX := pad:64[pad:32[mem[RBP + RAX - 0x20]]]
.address 0x400B15
.tainted-regs {RBP => [%00000576]}
00000989: RAX := pad:64[mem[RBP - 0x3C, el]:u32]
.address 0x400B18
.tainted-regs {RBP => [%00000576]}
00000990: mem := mem with [RBP + RAX - 0x20] <- low:8[RDX]
.address 0x400B1C
.tainted-regs {RBP => [%00000576]}
00000997: RAX := pad:64[mem[RBP - 0x34, el]:u32]
.address 0x400B1F
0000099e: RDX := pad:64[low:32[RAX - 1]]
.address 0x400B22
.tainted-regs {RBP => [%00000576]}
000009a5: RAX := pad:64[pad:32[mem[RBP - 0x3D]]]
.address 0x400B26
000009ac: RDX := pad:64[low:32[RDX]]
.address 0x400B28
.tainted-regs {RBP => [%00000576]}
000009b3: mem := mem with [RBP + RDX - 0x20] <- low:8[RAX]
.address 0x400B2C
.tainted-regs {RBP => [%00000576]}
000009c1: #95 := mem[RBP - 0x34, el]:u32
.address 0x400B2C
.tainted-regs {RBP => [%00000576]}
000009c4: mem := mem with [RBP - 0x34, el]:u32 <- mem[RBP - 0x34, el]:u32 - 1
.address 0x400B2C
000009c7: CF := #95 < 1
.address 0x400B2C
.tainted-regs {RBP => [%00000576]}
000009ca: OF := high:1[(#95 ^ 1) & (#95 ^ mem[RBP - 0x34, el]:u32)]
.address 0x400B2C
.tainted-regs {RBP => [%00000576]}
000009cd: AF := 0x10 = (0x10 & (mem[RBP - 0x34, el]:u32 ^ #95 ^ 1))
.address 0x400B2C
.tainted-regs {RBP => [%00000576]}
000009d0: PF := ~low:1[let $1 = mem[RBP - 0x34, el]:u32 >> 4 ^ mem[RBP - 0x34, el]:u32 in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400B2C
.tainted-regs {RBP => [%00000576]}
000009d3: SF := high:1[mem[RBP - 0x34, el]:u32]
.address 0x400B2C
.tainted-regs {RBP => [%00000576]}
000009d6: ZF := 0 = mem[RBP - 0x34, el]:u32
.address 0x400B30
.tainted-regs {RBP => [%00000576]}
000009e4: #98 := mem[RBP - 0x3C, el]:u32
.address 0x400B30
.tainted-regs {RBP => [%00000576]}
000009e7: mem := mem with [RBP - 0x3C, el]:u32 <- mem[RBP - 0x3C, el]:u32 + 1
.address 0x400B30
.tainted-regs {RBP => [%00000576]}
000009ea: CF := mem[RBP - 0x3C, el]:u32 < #98
.address 0x400B30
.tainted-regs {RBP => [%00000576]}
000009ed: OF := ~high:1[#98] & (high:1[#98] | high:1[mem[RBP - 0x3C, el]:u32]) & ~(
high:1[#98] & high:1[mem[RBP - 0x3C, el]:u32])
.address 0x400B30
.tainted-regs {RBP => [%00000576]}
000009f0: AF := 0x10 = (0x10 & (mem[RBP - 0x3C, el]:u32 ^ #98 ^ 1))
.address 0x400B30
.tainted-regs {RBP => [%00000576]}
000009f3: PF := ~low:1[let $1 = mem[RBP - 0x3C, el]:u32 >> 4 ^ mem[RBP - 0x3C, el]:u32 in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400B30
.tainted-regs {RBP => [%00000576]}
000009f6: SF := high:1[mem[RBP - 0x3C, el]:u32]
.address 0x400B30
.tainted-regs {RBP => [%00000576]}
000009f9: ZF := 0 = mem[RBP - 0x3C, el]:u32
00001439: goto %000008ff

.address 0x400AAB
00000713: 
.address 0x400AAB
.tainted-regs {RBP => [%00000576]}
00000723: RCX := pad:64[mem[RBP - 0x44, el]:u32]
.address 0x400AAE
0000072a: RDX := 0xAAAAAAAB
.address 0x400AB3
00000731: RAX := pad:64[low:32[RCX]]
.address 0x400AB5
00000740: #66 := pad:64[low:32[RAX]] * pad:64[low:32[RDX]]
.address 0x400AB5
00000743: RAX := pad:64[extract:31:0[#66]]
.address 0x400AB5
00000746: RDX := pad:64[extract:63:32[#66]]
.address 0x400AB5
00000749: OF := extract:63:32[#66] <> 0
.address 0x400AB5
0000074c: CF := extract:63:32[#66] <> 0
.address 0x400AB5
0000074f: SF := unknown[bits]:u1
.address 0x400AB5
00000752: ZF := unknown[bits]:u1
.address 0x400AB5
00000755: AF := unknown[bits]:u1
.address 0x400AB5
00000758: PF := unknown[bits]:u1
.address 0x400AB7
00000766: #67 := low:32[RDX]
.address 0x400AB7
00000769: RDX := pad:64[low:32[RDX] >> 1]
.address 0x400AB7
0000076c: CF := high:1[#67 << 0x1F]
.address 0x400AB7
0000076f: SF := high:1[low:32[RDX]]
.address 0x400AB7
00000772: ZF := 0 = low:32[RDX]
.address 0x400AB7
00000775: PF := ~low:1[let $1 = low:32[RDX] >> 4 ^ low:32[RDX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400AB7
00000778: AF := unknown[bits]:u1
.address 0x400AB7
0000077b: OF := high:1[#67]
.address 0x400AB9
00000782: RAX := pad:64[low:32[RDX]]
.address 0x400ABB
00000791: #69 := low:32[RAX]
.address 0x400ABB
00000794: #70 := low:32[RAX]
.address 0x400ABB
00000797: RAX := pad:64[low:32[RAX] + #70]
.address 0x400ABB
0000079a: CF := low:32[RAX] < #69
.address 0x400ABB
0000079d: OF := high:1[#69] = high:1[#70] & (high:1[#69] | high:1[low:32[RAX]]) & ~(
high:1[#69] & high:1[low:32[RAX]])
.address 0x400ABB
000007a0: AF := 0x10 = (0x10 & (low:32[RAX] ^ #69 ^ #70))
.address 0x400ABB
000007a3: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400ABB
000007a6: SF := high:1[low:32[RAX]]
.address 0x400ABB
000007a9: ZF := 0 = low:32[RAX]
.address 0x400ABD
000007b8: #72 := low:32[RAX]
.address 0x400ABD
000007bb: #73 := low:32[RDX]
.address 0x400ABD
000007be: RAX := pad:64[low:32[RAX] + #73]
.address 0x400ABD
000007c1: CF := low:32[RAX] < #72
.address 0x400ABD
000007c4: OF := high:1[#72] = high:1[#73] & (high:1[#72] | high:1[low:32[RAX]]) & ~(
high:1[#72] & high:1[low:32[RAX]])
.address 0x400ABD
000007c7: AF := 0x10 = (0x10 & (low:32[RAX] ^ #72 ^ #73))
.address 0x400ABD
000007ca: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400ABD
000007cd: SF := high:1[low:32[RAX]]
.address 0x400ABD
000007d0: ZF := 0 = low:32[RAX]
.address 0x400ABF
000007df: #75 := low:32[RCX]
.address 0x400ABF
000007e2: #76 := low:32[RAX]
.address 0x400ABF
000007e5: RCX := pad:64[low:32[RCX] - low:32[RAX]]
.address 0x400ABF
000007e8: CF := #75 < #76
.address 0x400ABF
000007eb: OF := high:1[(#75 ^ #76) & (#75 ^ low:32[RCX])]
.address 0x400ABF
000007ee: AF := 0x10 = (0x10 & (low:32[RCX] ^ #75 ^ #76))
.address 0x400ABF
000007f1: PF := ~low:1[let $1 = low:32[RCX] >> 4 ^ low:32[RCX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400ABF
000007f4: SF := high:1[low:32[RCX]]
.address 0x400ABF
000007f7: ZF := 0 = low:32[RCX]
.address 0x400AC1
000007fe: RDX := pad:64[low:32[RCX]]
.address 0x400AC3
00000805: RDX := pad:64[low:32[RDX]]
.address 0x400AC5
.tainted-regs {RBP => [%00000576]}
0000080c: RAX := mem[RBP - 0x28, el]:u64
.address 0x400AC9
0000081b: #78 := RAX
.address 0x400AC9
0000081e: #79 := RDX
.address 0x400AC9
00000821: RAX := RAX + #79
.address 0x400AC9
00000824: CF := RAX < #78
.address 0x400AC9
00000827: OF := high:1[#78] = high:1[#79] & (high:1[#78] | high:1[RAX]) & ~(
high:1[#78] & high:1[RAX])
.address 0x400AC9
0000082a: AF := 0x10 = (0x10 & (RAX ^ #78 ^ #79))
.address 0x400AC9
0000082d: PF := ~low:1[let $1 = RAX >> 4 ^ RAX in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400AC9
00000830: SF := high:1[RAX]
.address 0x400AC9
00000833: ZF := 0 = RAX
.address 0x400ACC
0000083a: RDX := pad:64[pad:32[mem[RAX]]]
.address 0x400ACF
.tainted-regs {RBP => [%00000576]}
00000841: RAX := pad:64[mem[RBP - 0x34, el]:u32]
.address 0x400AD2
.tainted-regs {RBP => [%00000576]}
00000848: mem := mem with [RBP + RAX - 0x20] <- low:8[RDX]
.address 0x400AD6
.tainted-regs {RBP => [%00000576]}
0000084f: RAX := pad:64[mem[RBP - 0x44, el]:u32]
.address 0x400AD9
0000085d: #81 := low:32[RAX]
.address 0x400AD9
00000860: RAX := pad:64[low:32[RAX] + 1]
.address 0x400AD9
00000863: CF := low:32[RAX] < #81
.address 0x400AD9
00000866: OF := ~high:1[#81] & (high:1[#81] | high:1[low:32[RAX]]) & ~(
high:1[#81] & high:1[low:32[RAX]])
.address 0x400AD9
00000869: AF := 0x10 = (0x10 & (low:32[RAX] ^ #81 ^ 1))
.address 0x400AD9
0000086c: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400AD9
0000086f: SF := high:1[low:32[RAX]]
.address 0x400AD9
00000872: ZF := 0 = low:32[RAX]
.address 0x400ADC
00000879: RDX := 0xAAAAAAAB
.address 0x400AE1
00000888: #84 := pad:64[low:32[RAX]] * pad:64[low:32[RDX]]
.address 0x400AE1
0000088b: RAX := pad:64[extract:31:0[#84]]
.address 0x400AE1
0000088e: RDX := pad:64[extract:63:32[#84]]
.address 0x400AE1
00000891: OF := extract:63:32[#84] <> 0
.address 0x400AE1
00000894: CF := extract:63:32[#84] <> 0
.address 0x400AE1
00000897: SF := unknown[bits]:u1
.address 0x400AE1
0000089a: ZF := unknown[bits]:u1
.address 0x400AE1
0000089d: AF := unknown[bits]:u1
.address 0x400AE1
000008a0: PF := unknown[bits]:u1
.address 0x400AE3
000008a7: RAX := pad:64[low:32[RDX]]
.address 0x400AE5
000008b5: #85 := low:32[RAX]
.address 0x400AE5
000008b8: RAX := pad:64[low:32[RAX] >> 1]
.address 0x400AE5
000008bb: CF := high:1[#85 << 0x1F]
.address 0x400AE5
000008be: SF := high:1[low:32[RAX]]
.address 0x400AE5
000008c1: ZF := 0 = low:32[RAX]
.address 0x400AE5
000008c4: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400AE5
000008c7: AF := unknown[bits]:u1
.address 0x400AE5
000008ca: OF := high:1[#85]
.address 0x400AE7
.tainted-regs {RBP => [%00000576]}
000008d1: mem := mem with [RBP - 0x44, el]:u32 <- low:32[RAX]
.address 0x400AEA
.tainted-regs {RBP => [%00000576]}
000008df: #87 := mem[RBP - 0x34, el]:u32
.address 0x400AEA
.tainted-regs {RBP => [%00000576]}
000008e2: mem := mem with [RBP - 0x34, el]:u32 <- mem[RBP - 0x34, el]:u32 + 1
.address 0x400AEA
.tainted-regs {RBP => [%00000576]}
000008e5: CF := mem[RBP - 0x34, el]:u32 < #87
.address 0x400AEA
.tainted-regs {RBP => [%00000576]}
000008e8: OF := ~high:1[#87] & (high:1[#87] | high:1[mem[RBP - 0x34, el]:u32]) & ~(
high:1[#87] & high:1[mem[RBP - 0x34, el]:u32])
.address 0x400AEA
.tainted-regs {RBP => [%00000576]}
000008eb: AF := 0x10 = (0x10 & (mem[RBP - 0x34, el]:u32 ^ #87 ^ 1))
.address 0x400AEA
.tainted-regs {RBP => [%00000576]}
000008ee: PF := ~low:1[let $1 = mem[RBP - 0x34, el]:u32 >> 4 ^ mem[RBP - 0x34, el]:u32 in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400AEA
.tainted-regs {RBP => [%00000576]}
000008f1: SF := high:1[mem[RBP - 0x34, el]:u32]
.address 0x400AEA
.tainted-regs {RBP => [%00000576]}
000008f4: ZF := 0 = mem[RBP - 0x34, el]:u32
0000143a: goto %000006ed


.address 0x4008D6
00001412: sub main(main_argc, main_argv, main_result)
00001450: main_argc :: in u32 = RDI
00001451: main_argv :: in out u64 = RSI
00001452: main_result :: out u32 = RAX
.address 0x4008D6
0000032b: 
.address 0x4008D6
00000332: #34 := RBP
.address 0x4008D6
00000335: RSP := RSP - 8
.address 0x4008D6
00000338: mem := mem with [RSP, el]:u64 <- #34
.address 0x4008D7
0000033f: RBP := RSP
.address 0x4008DA
0000034d: #35 := RSP
.address 0x4008DA
00000350: RSP := RSP - 0x50
.address 0x4008DA
00000353: CF := #35 < 0x50
.address 0x4008DA
00000356: OF := high:1[(#35 ^ 0x50) & (#35 ^ RSP)]
.address 0x4008DA
00000359: AF := 0x10 = (0x10 & (RSP ^ #35 ^ 0x50))
.address 0x4008DA
0000035c: PF := ~low:1[let $1 = RSP >> 4 ^ RSP in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x4008DA
0000035f: SF := high:1[RSP]
.address 0x4008DA
00000362: ZF := 0 = RSP
.address 0x4008DE
00000369: RAX := mem[FS_BASE + 0x28, el]:u64
.address 0x4008E7
00000370: mem := mem with [RBP - 8, el]:u64 <- RAX
.address 0x4008EB
0000037d: RAX := 0
.address 0x4008EB
00000380: AF := unknown[bits]:u1
.address 0x4008EB
00000383: ZF := 1
.address 0x4008EB
00000386: PF := 1
.address 0x4008EB
00000389: OF := 0
.address 0x4008EB
0000038c: CF := 0
.address 0x4008EB
0000038f: SF := 0
.address 0x4008ED
00000396: RDI := 0x400C78
.address 0x4008F2
0000039d: RAX := 0
.address 0x4008F7
000003a7: RSP := RSP - 8
.address 0x4008F7
000003aa: mem := mem with [RSP, el]:u64 <- 0x4008FC
.address 0x4008F7
00001479: printf_format := RDI
.address 0x4008F7
000003ad: call @printf with return %000003af

.address 0x4008FC
000003af: 
.address 0x4008F7
0000148a: printf_result := RAX
.address 0x4008FC
000003b4: RAX := mem[0x602090, el]:u64
.address 0x400903
000003bb: RDI := RAX
.address 0x400906
000003c5: RSP := RSP - 8
.address 0x400906
000003c8: mem := mem with [RSP, el]:u64 <- 0x40090B
.address 0x400906
000003cb: call @fflush with return %000003cd

.address 0x40090B
000003cd: 
.address 0x40090B
000003d2: RDX := mem[0x6020A0, el]:u64
.address 0x400912
000003d9: RAX := low:64[RBP - 0x30]
.address 0x400916
000003e0: RSI := 0x20
.address 0x40091B
000003e7: RDI := RAX
.address 0x40091E
000003f1: RSP := RSP - 8
.address 0x40091E
000003f4: mem := mem with [RSP, el]:u64 <- 0x400923
.address 0x40091E
0000147a: fgets_size := RSI
.address 0x40091E
0000147b: fgets_s := RDI
.address 0x40091E
0000147c: fgets_stream := RDX
.address 0x40091E
000003f7: call @fgets with return %000003f9

.address 0x400923
000003f9: 
.address 0x40091E
0000148d: fgets_stream := RDX
.address 0x40091E
0000148c: fgets_s := RDI
.address 0x40091E
0000148b: fgets_result := RAX
.address 0x400923
00000404: #38 := RAX
.address 0x400923
00000407: OF := 0
.address 0x400923
0000040a: CF := 0
.address 0x400923
0000040d: AF := unknown[bits]:u1
.address 0x400923
00000410: PF := ~low:1[let $1 = #38 >> 4 ^ #38 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400923
00000413: SF := high:1[#38]
.address 0x400923
00000416: ZF := 0 = #38
.address 0x400926
00000420: when ~ZF goto %0000041a
0000143b: goto %000010a7

.address 0x40093C
0000041a: 
.address 0x40093C
0000042a: RAX := low:64[RBP - 0x30]
.address 0x400940
00000431: RDI := RAX
.address 0x400943
0000043b: RSP := RSP - 8
.address 0x400943
0000043e: mem := mem with [RSP, el]:u64 <- 0x400948
.address 0x400943
0000147d: strlen_s := RDI
.address 0x400943
00000441: call @strlen with return %00000443

.address 0x400948
00000443: 
.address 0x400943
0000148e: strlen_result := RAX
.address 0x400948
00000448: mem := mem with [RBP - 0x40, el]:u32 <- low:32[RAX]
.address 0x40094B
0000044f: RAX := pad:64[mem[RBP - 0x40, el]:u32]
.address 0x40094E
0000045d: #40 := low:32[RAX]
.address 0x40094E
00000460: RAX := pad:64[low:32[RAX] - 1]
.address 0x40094E
00000463: CF := #40 < 1
.address 0x40094E
00000466: OF := high:1[(#40 ^ 1) & (#40 ^ low:32[RAX])]
.address 0x40094E
00000469: AF := 0x10 = (0x10 & (low:32[RAX] ^ #40 ^ 1))
.address 0x40094E
0000046c: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x40094E
0000046f: SF := high:1[low:32[RAX]]
.address 0x40094E
00000472: ZF := 0 = low:32[RAX]
.address 0x400951
00000479: RAX := pad:64[low:32[RAX]]
.address 0x400953
00000480: RAX := pad:64[pad:32[mem[RBP + RAX - 0x30]]]
.address 0x400958
0000048d: #43 := low:8[RAX] - 0xA
.address 0x400958
00000490: CF := low:8[RAX] < 0xA
.address 0x400958
00000493: OF := high:1[(low:8[RAX] ^ 0xA) & (low:8[RAX] ^ #43)]
.address 0x400958
00000496: AF := 0x10 = (0x10 & (#43 ^ low:8[RAX] ^ 0xA))
.address 0x400958
00000499: PF := ~low:1[let $1 = #43 >> 4 ^ #43 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400958
0000049c: SF := high:1[#43]
.address 0x400958
0000049f: ZF := 0 = #43
.address 0x40095A
000004a9: when ZF goto %000004a3
0000143c: goto %00001083

.address 0x400970
000004a3: 
.address 0x400970
000004b3: RAX := pad:64[mem[RBP - 0x40, el]:u32]
.address 0x400973
000004c1: #45 := low:32[RAX]
.address 0x400973
000004c4: RAX := pad:64[low:32[RAX] - 1]
.address 0x400973
000004c7: CF := #45 < 1
.address 0x400973
000004ca: OF := high:1[(#45 ^ 1) & (#45 ^ low:32[RAX])]
.address 0x400973
000004cd: AF := 0x10 = (0x10 & (low:32[RAX] ^ #45 ^ 1))
.address 0x400973
000004d0: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400973
000004d3: SF := high:1[low:32[RAX]]
.address 0x400973
000004d6: ZF := 0 = low:32[RAX]
.address 0x400976
000004dd: RAX := pad:64[low:32[RAX]]
.address 0x400978
000004e4: mem := mem with [RBP + RAX - 0x30] <- 0
.address 0x40097D
000004f2: #48 := mem[RBP - 0x40, el]:u32
.address 0x40097D
000004f5: mem := mem with [RBP - 0x40, el]:u32 <- mem[RBP - 0x40, el]:u32 - 1
.address 0x40097D
000004f8: CF := #48 < 1
.address 0x40097D
000004fb: OF := high:1[(#48 ^ 1) & (#48 ^ mem[RBP - 0x40, el]:u32)]
.address 0x40097D
000004fe: AF := 0x10 = (0x10 & (mem[RBP - 0x40, el]:u32 ^ #48 ^ 1))
.address 0x40097D
00000501: PF := ~low:1[let $1 = mem[RBP - 0x40, el]:u32 >> 4 ^ mem[RBP - 0x40, el]:u32 in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x40097D
00000504: SF := high:1[mem[RBP - 0x40, el]:u32]
.address 0x40097D
00000507: ZF := 0 = mem[RBP - 0x40, el]:u32
.address 0x400981
0000050e: RAX := pad:64[mem[RBP - 0x40, el]:u32]
.address 0x400984
0000051c: #51 := low:32[RAX]
.address 0x400984
0000051f: RAX := pad:64[low:32[RAX] << 3]
.address 0x400984
00000522: CF := low:1[#51 >> 0x1D]
.address 0x400984
00000525: SF := high:1[low:32[RAX]]
.address 0x400984
00000528: ZF := 0 = low:32[RAX]
.address 0x400984
0000052b: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400984
0000052e: AF := unknown[bits]:u1
.address 0x400984
00000531: OF := unknown[bits]:u1
.address 0x400987
0000053f: #53 := low:32[RAX]
.address 0x400987
00000542: RAX := pad:64[low:32[RAX] + 1]
.address 0x400987
00000545: CF := low:32[RAX] < #53
.address 0x400987
00000548: OF := ~high:1[#53] & (high:1[#53] | high:1[low:32[RAX]]) & ~(
high:1[#53] & high:1[low:32[RAX]])
.address 0x400987
0000054b: AF := 0x10 = (0x10 & (low:32[RAX] ^ #53 ^ 1))
.address 0x400987
0000054e: PF := ~low:1[let $1 = low:32[RAX] >> 4 ^ low:32[RAX] in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x400987
00000551: SF := high:1[low:32[RAX]]
.address 0x400987
00000554: ZF := 0 = low:32[RAX]
.address 0x40098A
0000055b: mem := mem with [RBP - 0x3C, el]:u32 <- low:32[RAX]
.address 0x40098D
00000562: RAX := pad:64[mem[RBP - 0x3C, el]:u32]
.address 0x400990
00000569: RDI := RAX
.address 0x400993
.tainted-regs {RSP => [%00000573]}
00000573: RSP := RSP - 8
.address 0x400993
.tainted-regs {RSP => [%00000573, %00000576], mem => [%00000576]}
00000576: mem := mem with [RSP, el]:u64 <- 0x400998
.address 0x400993
.tainted-regs {RDI => [%00000579]}
0000147e: malloc_size := RDI
.address 0x400993
00000579: call @malloc with return %0000057b

.address 0x400998
0000057b: 
.address 0x400993
.tainted-regs {RAX => [%00000579]}
0000148f: malloc_result := RAX
.address 0x400998
.tainted-regs {RAX => [%00000579]}
00000580: mem := mem with [RBP - 0x38, el]:u64 <- RAX
.address 0x40099C
0000058d: #56 := mem[RBP - 0x38, el]:u64
.address 0x40099C
00000590: CF := mem[RBP - 0x38, el]:u64 < 0
.address 0x40099C
.tainted-regs {#56 => [%00000579]}
00000593: OF := high:1[mem[RBP - 0x38, el]:u64 & (mem[RBP - 0x38, el]:u64 ^ #56)]
.address 0x40099C
.tainted-regs {#56 => [%00000579]}
00000596: AF := 0x10 = (0x10 & (#56 ^ mem[RBP - 0x38, el]:u64))
.address 0x40099C
.tainted-regs {$1 => [%00000579], $2 => [%00000579], #56 => [%00000579]}
00000599: PF := ~low:1[let $1 = #56 >> 4 ^ #56 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x40099C
.tainted-regs {#56 => [%00000579]}
0000059c: SF := high:1[#56]
.address 0x40099C
.tainted-regs {#56 => [%00000579]}
0000059f: ZF := 0 = #56
.address 0x4009A1
.tainted-regs {ZF => [%00000579]}
000005a9: when ~ZF goto %000005a3
0000143d: goto %00001075

.address 0x4009AD
000005a3: 
.address 0x4009AD
000005b3: RDX := pad:64[mem[RBP - 0x3C, el]:u32]
.address 0x4009B0
000005ba: RAX := mem[RBP - 0x38, el]:u64
.address 0x4009B4
000005c1: RSI := 0
.address 0x4009B9
.tainted-regs {RAX => [%00000579]}
000005c8: RDI := RAX
.address 0x4009BC
.tainted-regs {RSP => [%00000576]}
000005d2: RSP := RSP - 8
.address 0x4009BC
.tainted-regs {RSP => [%00000576]}
000005d5: mem := mem with [RSP, el]:u64 <- 0x4009C1
.address 0x4009BC
0000147f: memset_c := RSI
.address 0x4009BC
00001480: memset_n := RDX
.address 0x4009BC
.tainted-regs {RDI => [%00000579]}
00001481: memset_buf := RDI
.address 0x4009BC
000005d8: call @memset with return %000005da

.address 0x4009C1
000005da: 
.address 0x4009BC
.tainted-regs {RDI => [%00000579]}
00001491: memset_buf := RDI
.address 0x4009BC
.tainted-regs {RAX => [%00000579]}
00001490: memset_result := RAX
.address 0x4009C1
000005df: mem := mem with [RBP - 0x44, el]:u32 <- 0
.address 0x4009C8
000005e7: goto %000005e3

.address 0x4009E9
000005e3: 
.address 0x4009E9
.tainted-regs {RBP => [%00000576]}
000005ed: RAX := pad:64[mem[RBP - 0x44, el]:u32]
.address 0x4009EC
.tainted-regs {RBP => [%00000576]}
000005fa: #58 := low:32[RAX] - mem[RBP - 0x40, el]:u32
.address 0x4009EC
.tainted-regs {RBP => [%00000576]}
000005fd: CF := low:32[RAX] < mem[RBP - 0x40, el]:u32
.address 0x4009EC
.tainted-regs {RBP => [%00000576]}
00000600: OF := high:1[(low:32[RAX] ^ mem[RBP - 0x40, el]:u32) & (low:32[RAX] ^ #58)]
.address 0x4009EC
.tainted-regs {RBP => [%00000576]}
00000603: AF := 0x10 = (0x10 & (#58 ^ low:32[RAX] ^ mem[RBP - 0x40, el]:u32))
.address 0x4009EC
00000606: PF := ~low:1[let $1 = #58 >> 4 ^ #58 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x4009EC
00000609: SF := high:1[#58]
.address 0x4009EC
0000060c: ZF := 0 = #58
.address 0x4009EF
00000616: when CF goto %00000610
0000143e: goto %00000f23

.address 0x4009F1
00000f23: 
.address 0x4009F1
.tainted-regs {RBP => [%00000576]}
00000f28: RAX := mem[RBP - 0x38, el]:u64
.address 0x4009F5
00000f2f: RSI := 0x400CA8
.address 0x4009FA
00000f36: RDI := RAX
.address 0x4009FD
.tainted-regs {RSP => [%00000576]}
00000f40: RSP := RSP - 8
.address 0x4009FD
.tainted-regs {RSP => [%00000576]}
00000f43: mem := mem with [RSP, el]:u64 <- 0x400A02
.address 0x4009FD
00001482: strcmp_s1 := RDI
.address 0x4009FD
00001483: strcmp_s2 := RSI
.address 0x4009FD
00000f46: call @strcmp with return %00000f48

.address 0x400A02
00000f48: 
.address 0x4009FD
00001492: strcmp_result := RAX
.address 0x400A02
00000f53: #151 := low:32[RAX]
.address 0x400A02
00000f56: OF := 0
.address 0x400A02
00000f59: CF := 0
.address 0x400A02
00000f5c: AF := unknown[bits]:u1
.address 0x400A02
00000f5f: PF := ~low:1[let $1 = #151 >> 4 ^ #151 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400A02
00000f62: SF := high:1[#151]
.address 0x400A02
00000f65: ZF := 0 = #151
.address 0x400A04
00000f6f: when ZF goto %00000f69
0000143f: goto %0000102c

.address 0x400A2B
00000f69: 
.address 0x400A2B
.tainted-regs {RBP => [%00000576]}
00000f79: RAX := low:64[RBP - 0x30]
.address 0x400A2F
.tainted-regs {RAX => [%00000576]}
00000f80: RSI := RAX
.address 0x400A32
00000f87: RDI := 0x400D20
.address 0x400A37
00000f8e: RAX := 0
.address 0x400A3C
.tainted-regs {RSP => [%00000576]}
00000f97: RSP := RSP - 8
.address 0x400A3C
.tainted-regs {RSP => [%00000576]}
00000f9a: mem := mem with [RSP, el]:u64 <- 0x400A41
.address 0x400A3C
00001484: printf_format := RDI
.address 0x400A3C
00000f9d: call @printf with return %00000f9f

.address 0x400A41
00000f9f: 
.address 0x400A3C
00001493: printf_result := RAX
.address 0x400A41
.tainted-regs {RBP => [%00000576]}
00000fa4: RAX := mem[RBP - 0x38, el]:u64
.address 0x400A45
00000fab: RDI := RAX
.address 0x400A48
.tainted-regs {RSP => [%00000576]}
00000fb5: RSP := RSP - 8
.address 0x400A48
.tainted-regs {RSP => [%00000576]}
00000fb8: mem := mem with [RSP, el]:u64 <- 0x400A4D
.address 0x400A48
00001485: free_ptr := RDI
.address 0x400A48
00000fbb: call @free with return %00000fbd

.address 0x400A4D
00000fbd: 
.address 0x400A48
00001494: free_ptr := RDI
.address 0x400A4D
.tainted-regs {RBP => [%00000576]}
00000fc2: mem := mem with [RBP - 0x38, el]:u64 <- 0
.address 0x400A55
00000fc9: RAX := 0
00001440: goto %00000fcb

.address 0x400A06
0000102c: 
.address 0x400A06
00001031: RDI := 0x400C8A
.address 0x400A0B
.tainted-regs {RSP => [%00000576]}
0000103b: RSP := RSP - 8
.address 0x400A0B
.tainted-regs {RSP => [%00000576]}
0000103e: mem := mem with [RSP, el]:u64 <- 0x400A10
.address 0x400A0B
00001486: puts_s := RDI
.address 0x400A0B
00001041: call @puts with return %00001043

.address 0x400A10
00001043: 
.address 0x400A0B
00001495: puts_result := RAX
.address 0x400A10
.tainted-regs {RBP => [%00000576]}
00001048: RAX := mem[RBP - 0x38, el]:u64
.address 0x400A14
0000104f: RDI := RAX
.address 0x400A17
.tainted-regs {RSP => [%00000576]}
00001058: RSP := RSP - 8
.address 0x400A17
.tainted-regs {RSP => [%00000576]}
0000105b: mem := mem with [RSP, el]:u64 <- 0x400A1C
.address 0x400A17
00001487: free_ptr := RDI
.address 0x400A17
0000105e: call @free with return %00001060

.address 0x400A1C
00001060: 
.address 0x400A17
00001496: free_ptr := RDI
.address 0x400A1C
.tainted-regs {RBP => [%00000576]}
00001065: mem := mem with [RBP - 0x38, el]:u64 <- 0
.address 0x400A24
0000106c: RAX := 0
.address 0x400A29
00001073: goto %00000fcb

.address 0x4009CA
00000610: 
.address 0x4009CA
00000620: RAX := pad:64[mem[RBP - 0x44, el]:u32]
.address 0x4009CD
00000627: RAX := extend:64[low:32[RAX]]
.address 0x4009CF
0000062e: RAX := pad:64[pad:32[mem[RBP + RAX - 0x30]]]
.address 0x4009D4
00000635: RAX := pad:64[extend:32[low:8[RAX]]]
.address 0x4009D7
0000063c: RDX := mem[RBP - 0x38, el]:u64
.address 0x4009DB
.tainted-regs {RDX => [%00000579]}
00000643: RSI := RDX
.address 0x4009DE
0000064a: RDI := pad:64[low:32[RAX]]
.address 0x4009E0
.tainted-regs {RSP => [%00000576]}
00000654: RSP := RSP - 8
.address 0x4009E0
.tainted-regs {RSP => [%00000576]}
00000657: mem := mem with [RSP, el]:u64 <- 0x4009E5
.address 0x4009E0
0000065a: call @hash with return %00000f00

.address 0x4009E5
00000f00: 
.address 0x4009E5
.tainted-regs {RBP => [%00000576]}
00000f0c: #148 := mem[RBP - 0x44, el]:u32
.address 0x4009E5
.tainted-regs {RBP => [%00000576]}
00000f0f: mem := mem with [RBP - 0x44, el]:u32 <- mem[RBP - 0x44, el]:u32 + 1
.address 0x4009E5
.tainted-regs {RBP => [%00000576]}
00000f12: CF := mem[RBP - 0x44, el]:u32 < #148
.address 0x4009E5
.tainted-regs {RBP => [%00000576]}
00000f15: OF := ~high:1[#148] & (high:1[#148] | high:1[mem[RBP - 0x44, el]:u32]) & ~(
high:1[#148] & high:1[mem[RBP - 0x44, el]:u32])
.address 0x4009E5
.tainted-regs {RBP => [%00000576]}
00000f18: AF := 0x10 = (0x10 & (mem[RBP - 0x44, el]:u32 ^ #148 ^ 1))
.address 0x4009E5
.tainted-regs {RBP => [%00000576]}
00000f1b: PF := ~low:1[let $1 = mem[RBP - 0x44, el]:u32 >> 4 ^ mem[RBP - 0x44, el]:u32 in
let $2 = $1 >> 2 ^ $1 in $2 >> 1 ^ $2]
.address 0x4009E5
.tainted-regs {RBP => [%00000576]}
00000f1e: SF := high:1[mem[RBP - 0x44, el]:u32]
.address 0x4009E5
.tainted-regs {RBP => [%00000576]}
00000f21: ZF := 0 = mem[RBP - 0x44, el]:u32
00001441: goto %000005e3

.address 0x4009A3
00001075: 
.address 0x4009A3
0000107a: RAX := 1
.address 0x4009A8
00001081: goto %00000fcb

.address 0x40095C
00001083: 
.address 0x40095C
00001088: RDI := 0x400C8A
.address 0x400961
00001091: RSP := RSP - 8
.address 0x400961
00001094: mem := mem with [RSP, el]:u64 <- 0x400966
.address 0x400961
00001488: puts_s := RDI
.address 0x400961
00001097: call @puts with return %00001099

.address 0x400966
00001099: 
.address 0x400961
00001497: puts_result := RAX
.address 0x400966
0000109e: RAX := 0
.address 0x40096B
000010a5: goto %00000fcb

.address 0x400928
000010a7: 
.address 0x400928
000010ac: RDI := 0x400C8A
.address 0x40092D
000010b5: RSP := RSP - 8
.address 0x40092D
000010b8: mem := mem with [RSP, el]:u64 <- 0x400932
.address 0x40092D
00001489: puts_s := RDI
.address 0x40092D
000010bb: call @puts with return %000010bd

.address 0x400932
000010bd: 
.address 0x40092D
00001498: puts_result := RAX
.address 0x400932
000010c2: RAX := 0
.address 0x400937
000010c9: goto %00000fcb

.address 0x400A5A
00000fcb: 
.address 0x400A5A
.tainted-regs {RBP => [%00000576]}
00000fd0: RCX := mem[RBP - 8, el]:u64
.address 0x400A5E
00000fdd: RCX := RCX ^ mem[FS_BASE + 0x28, el]:u64
.address 0x400A5E
00000fe0: OF := 0
.address 0x400A5E
00000fe3: CF := 0
.address 0x400A5E
00000fe6: AF := unknown[bits]:u1
.address 0x400A5E
00000fe9: PF := ~low:1[let $1 = RCX >> 4 ^ RCX in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400A5E
00000fec: SF := high:1[RCX]
.address 0x400A5E
00000fef: ZF := 0 = RCX
.address 0x400A67
00000ff9: when ZF goto %00000ff3
00001442: goto %0000101d

.address 0x400A69
0000101d: 
.address 0x400A69
.tainted-regs {RSP => [%00000576]}
00001024: RSP := RSP - 8
.address 0x400A69
.tainted-regs {RSP => [%00000576]}
00001027: mem := mem with [RSP, el]:u64 <- 0x400A6E
.address 0x400A69
0000102a: call @__stack_chk_fail with return %00000ff3

.address 0x400A6E
00000ff3: 
.address 0x400A6E
.tainted-regs {RBP => [%00000576]}
00001005: RSP := RBP
.address 0x400A6E
.tainted-regs {RSP => [%00000576]}
00001008: RBP := mem[RSP, el]:u64
.address 0x400A6E
.tainted-regs {RSP => [%00000576]}
0000100b: RSP := RSP + 8
.address 0x400A6F
.tainted-regs {RSP => [%00000576]}
00001014: #154 := mem[RSP, el]:u64
.address 0x400A6F
.tainted-regs {RSP => [%00000576]}
00001017: RSP := RSP + 8
.address 0x400A6F
0000101b: call #154 with noreturn


.address 0x4007A0
0000141b: sub malloc(malloc_size, malloc_result)
.tainted-regs {RDI => [%00000579]}
00001453: malloc_size :: in u64 = RDI
.tainted-regs {RAX => [%00000579]}
00001454: malloc_result :: out u64 = RAX
.address 0x4007A0
0000056f: 
.address 0x4007A0
00001352: call mem[0x602068, el]:u64 with noreturn


.address 0x400750
0000141c: sub memset(memset_buf, memset_c, memset_n, memset_result)
.tainted-regs {RDI => [%00000579]}
00001455: memset_buf :: in out u64 = RDI
00001456: memset_c :: in u32 = RSI
00001457: memset_n :: in u64 = RDX
.tainted-regs {RAX => [%00000579]}
00001458: memset_result :: out u64 = RAX
.address 0x400750
000005ce: 
.address 0x400750
000012d5: call mem[0x602040, el]:u64 with noreturn


.address 0x400740
0000141d: sub printf(printf_format, printf_result)
00001459: printf_format :: in u64 = RDI
0000145a: printf_result :: out u32 = RAX
.address 0x400740
000003a3: 
.address 0x400740
000012bc: call mem[0x602038, el]:u64 with noreturn


.address 0x400710
0000141e: sub puts(puts_s, puts_result)
0000145b: puts_s :: in u64 = RDI
0000145c: puts_result :: out u32 = RAX
.address 0x400710
00001037: 
.address 0x400710
00001271: call mem[0x602020, el]:u64 with noreturn


.address 0x400850
0000141f: sub register_tm_clones()
.address 0x400850
0000013e: 
.address 0x400850
00000143: RSI := 0x602090
.address 0x400855
0000014c: #11 := RBP
.address 0x400855
0000014f: RSP := RSP - 8
.address 0x400855
00000152: mem := mem with [RSP, el]:u64 <- #11
.address 0x400856
00000160: #12 := RSI
.address 0x400856
00000163: RSI := RSI - 0x602090
.address 0x400856
00000166: CF := #12 < 0x602090
.address 0x400856
00000169: OF := high:1[(#12 ^ 0x602090) & (#12 ^ RSI)]
.address 0x400856
0000016c: AF := 0x10 = (0x10 & (RSI ^ #12 ^ 0x602090))
.address 0x400856
0000016f: PF := ~low:1[let $1 = RSI >> 4 ^ RSI in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400856
00000172: SF := high:1[RSI]
.address 0x400856
00000175: ZF := 0 = RSI
.address 0x40085D
00000183: #15 := RSI
.address 0x40085D
00000186: RSI := RSI ~>> 3
.address 0x40085D
00000189: CF := high:1[#15 << 0x3D]
.address 0x40085D
0000018c: SF := high:1[RSI]
.address 0x40085D
0000018f: ZF := 0 = RSI
.address 0x40085D
00000192: PF := ~low:1[let $1 = RSI >> 4 ^ RSI in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x40085D
00000195: AF := unknown[bits]:u1
.address 0x40085D
00000198: OF := unknown[bits]:u1
.address 0x400861
0000019f: RBP := RSP
.address 0x400864
000001a6: RAX := RSI
.address 0x400867
000001b4: #17 := RAX
.address 0x400867
000001b7: RAX := RAX >> 0x3F
.address 0x400867
000001ba: CF := high:1[#17 << 1]
.address 0x400867
000001bd: SF := high:1[RAX]
.address 0x400867
000001c0: ZF := 0 = RAX
.address 0x400867
000001c3: PF := ~low:1[let $1 = RAX >> 4 ^ RAX in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400867
000001c6: AF := unknown[bits]:u1
.address 0x400867
000001c9: OF := unknown[bits]:u1
.address 0x40086B
000001d8: #19 := RSI
.address 0x40086B
000001db: #20 := RAX
.address 0x40086B
000001de: RSI := RSI + #20
.address 0x40086B
000001e1: CF := RSI < #19
.address 0x40086B
000001e4: OF := high:1[#19] = high:1[#20] & (high:1[#19] | high:1[RSI]) & ~(
high:1[#19] & high:1[RSI])
.address 0x40086B
000001e7: AF := 0x10 = (0x10 & (RSI ^ #19 ^ #20))
.address 0x40086B
000001ea: PF := ~low:1[let $1 = RSI >> 4 ^ RSI in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x40086B
000001ed: SF := high:1[RSI]
.address 0x40086B
000001f0: ZF := 0 = RSI
.address 0x40086E
000001fe: #22 := RSI
.address 0x40086E
00000201: RSI := RSI ~>> 1
.address 0x40086E
00000204: CF := high:1[#22 << 0x3F]
.address 0x40086E
00000207: SF := high:1[RSI]
.address 0x40086E
0000020a: ZF := 0 = RSI
.address 0x40086E
0000020d: PF := ~low:1[let $1 = RSI >> 4 ^ RSI in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x40086E
00000210: AF := unknown[bits]:u1
.address 0x40086E
00000213: OF := 0
.address 0x400871
0000021d: when ZF goto %00000217
00001443: goto %00001102

.address 0x400873
00001102: 
.address 0x400873
00001107: RAX := 0
.address 0x400878
00001114: #156 := RAX
.address 0x400878
00001117: OF := 0
.address 0x400878
0000111a: CF := 0
.address 0x400878
0000111d: AF := unknown[bits]:u1
.address 0x400878
00001120: PF := ~low:1[let $1 = #156 >> 4 ^ #156 in let $2 = $1 >> 2 ^ $1 in
$2 >> 1 ^ $2]
.address 0x400878
00001123: SF := high:1[#156]
.address 0x400878
00001126: ZF := 0 = #156
.address 0x40087B
0000112f: when ZF goto %00000217
00001444: goto %00001135

.address 0x400888
00000217: 
.address 0x400888
00000228: RBP := mem[RSP, el]:u64
.address 0x400888
0000022b: RSP := RSP + 8
.address 0x400889
00000234: #24 := mem[RSP, el]:u64
.address 0x400889
00000237: RSP := RSP + 8
.address 0x400889
0000023b: call #24 with noreturn

.address 0x40087D
00001135: 
.address 0x40087D
0000113b: RBP := mem[RSP, el]:u64
.address 0x40087D
0000113e: RSP := RSP + 8
.address 0x40087E
00001145: RDI := 0x602090
.address 0x400883
0000114d: call RAX with noreturn


.address 0x4007C0
00001422: sub sprintf(sprintf_str, sprintf_format, sprintf_result)
.tainted-regs {RDI => [%00000576]}
0000145d: sprintf_str :: in out u64 = RDI
0000145e: sprintf_format :: in u64 = RSI
0000145f: sprintf_result :: out u32 = RAX
.address 0x4007C0
00000c0e: 
.address 0x4007C0
00001384: call mem[0x602078, el]:u64 with noreturn


.address 0x400790
00001423: sub strcmp(strcmp_s1, strcmp_s2, strcmp_result)
00001460: strcmp_s1 :: in u64 = RDI
00001461: strcmp_s2 :: in u64 = RSI
00001462: strcmp_result :: out u32 = RAX
.address 0x400790
00000f3c: 
.address 0x400790
00001339: call mem[0x602060, el]:u64 with noreturn


.address 0x400720
00001424: sub strlen(strlen_s, strlen_result)
00001463: strlen_s :: in u64 = RDI
00001464: strlen_result :: out u64 = RAX
.address 0x400720
00000437: 
.address 0x400720
0000128a: call mem[0x602028, el]:u64 with noreturn


.address 0x400760
00001425: sub strncat(strncat_dst, strncat_src, strncat_n, strncat_result)
.tainted-regs {RDI => [%00000579]}
00001465: strncat_dst :: in out u64 = RDI
.tainted-regs {RSI => [%00000576]}
00001466: strncat_src :: in u64 = RSI
00001467: strncat_n :: in u64 = RDX
.tainted-regs {RAX => [%00000579]}
00001468: strncat_result :: out u64 = RAX
.address 0x400760
00000c41: 
.address 0x400760
000012ee: call mem[0x602048, el]:u64 with noreturn



